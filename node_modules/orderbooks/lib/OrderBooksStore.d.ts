import { OrderBook, OrderBookOptions } from './OrderBook';
import { OrderBookLevelState } from './OrderBookLevel';
/**
 * Store for multi-symbol orderbooks, grouped into one book (OrderBook) per symbol
 *
 * `ExtraStateType` is optional extra state you may want to store with each orderbook level, completely optional. Inject a union type if desired.
 * @class OrderBooksStore
 */
export declare class OrderBooksStore<ExtraStateType = unknown> {
    books: Record<string, OrderBook<ExtraStateType>>;
    traceLog: boolean;
    shouldCheckTimestamp: boolean;
    maxDepth: number;
    constructor(options?: OrderBookOptions);
    /**
     * Get the current orderbook store for a symbol. Automatically initialised (empty), if none exists yet.
     * @param {string} symbol
     * @returns {OrderBook} created for symbol if not already tracked
     */
    getBook(symbol: string): OrderBook<ExtraStateType>;
    /**
     * @public Store/replace existing orderbook state in-memory
     *
     * @param {string} symbol
     * @param {Array} data current orderbook snapshot represented as array, where each child element is a level in the orderbook
     * @param {number} timestamp
     * @returns {OrderBook} store instance that handled this event
     */
    handleSnapshot(symbol: string, data: OrderBookLevelState[], timestamp?: number): OrderBook<ExtraStateType>;
    /**
     * @public Update existing orderbook state in-memory
     *
     * @param {string} symbol
     * @param {Array} deleteLevels - array with levels to delete
     * @param {Array} updateLevels - array with levels to update
     * @param {Array} insertLevels - array with levels to insert
     * @param {number} timestamp
     * @returns {OrderBook} store instance that handled this event
     */
    handleDelta(symbol: string, deleteLevels: OrderBookLevelState[] | undefined, updateLevels: OrderBookLevelState[] | undefined, insertLevels: OrderBookLevelState[] | undefined, timestamp?: number): OrderBook<ExtraStateType>;
}
